// new module script
#define FLT_MAX 340282346638528859811704183484516925440.0

// assertion check utility
void assert(bool expr)
{
  if (expr == false) AbortGame("Failed assertion!");
}

#region MATH_UTILITIES
static Vec2* Vec2::New(float x, float y) {
  Vec2* v = new Vec2;
  v.x = x;
  v.y = y;
  return v;
}
void  Vec2::Set(float x, float y) { this.x = x;  this.y = y; }
Vec2* Vec2::Negate() { return this.New(-this.x, -this.y); }
Vec2* Vec2::Minus(Vec2* v) { return this.New(this.x - v.x, this.y - v.y); }
Vec2* Vec2::Plus(Vec2* v) { return this.New(this.x + v.x, this.y + v.y); }
Vec2* Vec2::Scale(float a) { return this.New(this.x * a, this.y * a); }
float Vec2::Length(){ return Maths.Sqrt(this.x*this.x + this.y*this.y); }
float Vec2::Dot(Vec2* b) { return this.x * b.x + this.y * b.y; }
float Vec2::Cross(Vec2* b){	return this.x * b.y - this.y * b.x; }

static Mat22* Mat22::New(float col1_x, float col1_y, float col2_x, float col2_y)
{
  Mat22* m = new Mat22;
  m.col1_x = col1_x; m.col2_x = col2_x;
  m.col1_y = col1_y; m.col2_y = col2_y;
  return m;
}

static Mat22* Mat22::NewFromAngle(float angle)
{
  float c = Maths.Cos(angle), s = Maths.Sin(angle);
  return Mat22.New(c, s, -s, c);
}
  
static Mat22* Mat22::NewFromVec2(Vec2* col1, Vec2* col2)
{
  return Mat22.New(col1.x, col1.y, col2.x, col2.y);
}

Mat22* Mat22::Transpose() 
{
  return this.New(this.col1_x, this.col2_x, this.col1_y, this.col2_y);
}

Mat22* Mat22::Invert()
{
  float a = this.col1_x, b = this.col2_x, c = this.col1_y, d = this.col2_y;
  float det = a * d - b * c;
  assert(det != 0.0);
  det = 1.0 / det;
  return this.New(det * d, -det * c, -det * b, det * a);
}

Mat22* Mat22::Plus(Mat22* B)
{
	return this.New(this.col1_x + B.col1_x, this.col1_y + B.col1_y, this.col2_x + B.col2_x, this.col2_y + B.col2_y);
}


Vec2* CrossV2S(Vec2* a, float s)
{
	return Vec2.New(s * a.y, -s * a.x);
}

Vec2* CrossS2V(float s, Vec2* a)
{
	return Vec2.New(-s * a.y, s * a.x);
}

Vec2* MultiplyVec2(Mat22* A, Vec2* v)
{
	return Vec2.New(A.col1_x * v.x + A.col2_x * v.y, A.col1_y * v.x + A.col2_y * v.y);
}

Mat22* Mat22::Multiply(Mat22* matb)
{
   //A * B.col1, A * B.col2);
  float m11 = this.col1_x * matb.col1_x + this.col2_x * matb.col1_y;
  float m12 = this.col1_y * matb.col1_x + this.col2_y * matb.col1_y;
  
  float m21 = this.col1_x * matb.col2_x + this.col2_x * matb.col2_y;
  float m22 = this.col1_y * matb.col2_x + this.col2_y * matb.col2_y;
	return this.New(m11, m12, m21, m22);
}

int _maxi(int a, int b)
{
  if (a > b)
    return a;
  return b;
}

int _mini(int a, int b)
{
  if (a < b)
    return a;
  return b;
}

int _clampi(int v, int min, int max)
{
  return _mini(max, _maxi(v, min));
}

float _max(float a, float b)
{
  if (a > b)
    return a;
  return b;
}

float _min(float a, float b)
{
  if (a < b)
    return a;
  return b;
}

float _clamp(float v, float min, float max)
{
  return _min(max, _max(v, min));
}

// Random number in range [-1,1]
float _Random()
{
  float r = IntToFloat(Random(100000));
  r /= 100000.0;
  return 2.0 * r - 1.0;
}

float _RandomRange(float lo, float hi)
{
	float r = IntToFloat(Random(100000));
	r /= 100000.0;
	return (hi - lo) * r + lo;
}
#endregion //MATH_UTILITIES

bool _accumulateImpulses;
bool _warmStarting;
bool _positionCorrection;

static bool World::get_accumulateImpulses()
{
  return _accumulateImpulses;
}

static void World::set_accumulateImpulses(bool value)
{
  _accumulateImpulses = value;
}

static bool World::get_warmStarting()
{
  return _warmStarting;
}

static void World::set_warmStarting(bool value)
{
  _warmStarting = value;
}

static bool World::get_positionCorrection()
{
  return _positionCorrection;
}

static void World::set_positionCorrection(bool value)
{
  _positionCorrection = value;
}

void World::AddBody(Body* body)
{
	this.bodies[this.body_count] = body;
	this.body_count++;
}

void World::AddJoint(Joint* joint)
{
  this.joints[this.joint_count] = joint;
	this.joint_count++;
}

void Arbiters::Add(Arbiter* arb)
{
  this.a[this.a_count] = arb;
  this.a_count++;
}

void Contact::CopyTo(Contact* c)
{
  c.bias = this.bias;
  c.feature.value = this.feature.value;
  c.massNormal = this.massNormal;
  c.massTangent = this.massTangent;
  c.normal.Set(c.normal.x, c.normal.y);
  c.Pn = this.Pn;
  c.Pnb = this.Pnb;
  c.position.Set(c.position.x, c.position.y);
  c.Pt = this.Pt;
  c.r1.Set(this.r1.x, this.r1.y);
  c.r2.Set(this.r2.x, this.r2.y);
  c.separation = this.separation;
}

void Arbiters::Remove(Body* b1, Body* b2)
{
  int j=0;
  for(int i=0; i<this.a_count; i++)
  {
    if(this.a[i].body1 == b1 && this.a[i].body2 == b2) {
      continue;
    }
    this.a[j]= this.a[i];
    j++;
  }
  this.a_count-=1;
}

Arbiter* Arbiters::Get(Body* b1, Body* b2)
{
  for(int i=0; i<this.a_count; i++)
  {
    if(this.a[i].body1 == b1 && this.a[i].body2 == b2) {
      return this.a[i];
    }
  }
  return null;  
}

void Arbiters::Clear()
{
  for(int i=0; i<this.a_count; i++)
  {
    this.a[i] = null;
  }
  this.a_count = 0;
}

void World::Clear()
{
  for(int i=0; i<this.body_count; i++)
  {
    this.bodies[i] = null;
  }
  this.body_count = 0;
  
  for(int i=0; i<this.joint_count; i++)
  {
    this.joints[i] = null;
  }
  this.joint_count = 0;
  this.arbiters.Clear();
}


void FeaturePair::set_value(int v)
{
  this.inEdge1 = (v >> 24) & 0xff;
  this.inEdge2 = (v >> 16) & 0xff;
  this.outEdge1 = (v >> 8) & 0xff;
  this.outEdge2 = v & 0xff;
}

int FeaturePair::get_value()
{
  return this.inEdge1 << 24 + this.inEdge2 << 16 + this.outEdge1 << 8 + this.outEdge2;
}

void Body::Set(Vec2* w, float m)
{
  this.position_x = 0.0;
  this.position_y = 0.0;
  this.rotation = 0.0;
  this.velocity_x = 0.0;
  this.velocity_y = 0.0;
  this.angularVelocity = 0.0;
  this.force_x = 0.0;
  this.force_y = 0.0;
  this.torque = 0.0;
  this.friction = 0.2;
  
  this.width_x = w.x;
  this.width_y = w.y;
  this.mass = m;

	if (this.mass < FLT_MAX)
	{
		this.invMass = 1.0 / this.mass;
		this.I = this.mass * (this.width_x * this.width_x + this.width_y * this.width_y) / 12.0;
		this.invI = 1.0 / this.I;
	}
	else
	{
		this.invMass = 0.0;
		this.I = FLT_MAX;
		this.invI = 0.0;
	}
}

enum Axis
{
	FACE_A_X,
	FACE_A_Y,
	FACE_B_X,
	FACE_B_Y
};

enum EdgeNumbers
{
	NO_EDGE = 0,
	EDGE1,
	EDGE2,
	EDGE3,
	EDGE4
};

void Flip(FeaturePair* fp)
{
	char tmp = fp.inEdge1;
  fp.inEdge1 = fp.inEdge2;
  fp.inEdge2 = tmp;
  
	tmp = fp.outEdge1; 
  fp.outEdge1 = fp.outEdge2;
  fp.outEdge2 = tmp;
}

static Arbiter* Arbiter::Create(Body* b1, Body* b2)
{
  Arbiter* a = new Arbiter;
  a.body1 = b1;
	a.body2 = b2;

	//a.numContacts = Collide(a.contacts, a.body1, a.body2);

	a.friction = Maths.Sqrt(a.body1.friction * a.body2.friction);
  return a;
}

void Arbiter::Update(Contact* newContacts[], int numNewContacts)
{
	Contact* mergedContacts[2];
  mergedContacts[0] = new Contact;
  mergedContacts[1] = new Contact;

	for (int i=0; i < numNewContacts; i++)
	{
		Contact* cNew = newContacts[i];
		int k = -1;
		for (int j=0; j < this.numContacts; j++)
		{
			Contact* cOld = this.contacts[j];
			if (cNew.feature.value == cOld.feature.value)
			{
				k = j;
				break;
			}
		}

		if (k > -1)
		{
			Contact* c = mergedContacts[i];
			Contact* cOld = this.contacts[k];
			cNew.CopyTo(c);
			if (World.warmStarting)
			{
				c.Pn = cOld.Pn;
				c.Pt = cOld.Pt;
				c.Pnb = cOld.Pnb;
			}
			else
			{
				c.Pn = 0.0;
				c.Pt = 0.0;
				c.Pnb = 0.0;
			}
		}
		else
		{
			mergedContacts[i] = newContacts[i];
		}
	}

	for (int i = 0; i < numNewContacts; i++)
		this.contacts[i] = mergedContacts[i];

	this.numContacts = numNewContacts;
}


void Arbiter::ApplyImpulse()
{
	Body* b1 = this.body1;
	Body* b2 = this.body2;

	for (int i=0; i < this.numContacts; i++)
	{
		Contact* c = this.contacts[i];
		c.r1.x = c.position.x - b1.position_x;
    c.r1.y = c.position.y - b1.position_y;
		c.r2.x = c.position.x - b2.position_x;
    c.r2.y = c.position.y - b2.position_y;

		// Relative velocity at contact
		Vec2* tmpa = CrossS2V(b2.angularVelocity, c.r2);
    tmpa.x += b2.velocity_x;
    tmpa.y += b2.velocity_y;
    tmpa.x -= b1.velocity_x;
    tmpa.y -= b1.velocity_y;
    
    Vec2* tmpb = CrossS2V(b1.angularVelocity, c.r1);
    
    Vec2* dv = tmpa.Minus(tmpb);

		// Compute normal impulse
		float vn = dv.Dot(c.normal);

		float dPn = c.massNormal * (-vn + c.bias);

		if (_accumulateImpulses)
		{
			// Clamp the accumulated impulse
			float Pn0 = c.Pn;
			c.Pn = _max(Pn0 + dPn, 0.0);
			dPn = c.Pn - Pn0;
		}
		else
		{
			dPn = _max(dPn, 0.0);
		}

		// Apply contact impulse
		Vec2* Pn = c.normal.Scale(dPn);

		b1.velocity_x -= b1.invMass * Pn.x;
		b1.velocity_y -= b1.invMass * Pn.y;
		b1.angularVelocity -= b1.invI * c.r1.Cross(Pn);

    b2.velocity_x += b2.invMass * Pn.x;
		b2.velocity_y += b2.invMass * Pn.y;
		b2.angularVelocity += b2.invI * c.r2.Cross(Pn);
    
		// Relative velocity at contact
    
		tmpa = CrossS2V(b2.angularVelocity, c.r2);
    tmpa.x += b2.velocity_x;
    tmpa.y += b2.velocity_y;
    tmpa.x -= b1.velocity_x;
    tmpa.y -= b1.velocity_y;
    
    tmpb = CrossS2V(b1.angularVelocity, c.r1);
    
    dv = tmpa.Minus(tmpb);

		Vec2* tangent = CrossV2S(c.normal, 1.0);
		float vt = dv.Dot(tangent);
		float dPt = c.massTangent * (-vt);

		if (_accumulateImpulses)
		{
			// Compute friction impulse
			float maxPt = this.friction * c.Pn;

			// Clamp friction
			float oldTangentImpulse = c.Pt;
			c.Pt = _clamp(oldTangentImpulse + dPt, -maxPt, maxPt);
			dPt = c.Pt - oldTangentImpulse;
		}
		else
		{
			float maxPt = this.friction * dPn;
			dPt = _clamp(dPt, -maxPt, maxPt);
		}

		// Apply contact impulse
		Vec2* Pt = tangent.Scale(dPt);

		b1.velocity_x -= b1.invMass * Pt.x;
    b1.velocity_y -= b1.invMass * Pt.y;
    b1.angularVelocity -= b1.invI * c.r1.Cross(Pt);

		b2.velocity_x += b2.invMass * Pt.x;
    b2.velocity_y += b2.invMass * Pt.y;
		b2.angularVelocity += b2.invI * c.r2.Cross(Pt);
	}
}

void Arbiter::PreStep(float inv_dt)
{
	float k_allowedPenetration = 0.01;
	float k_biasFactor = 0.0;
  if(_positionCorrection) k_biasFactor = 0.2;

	for (int i = 0; i < this.numContacts; i++)
	{
		Contact* c = this.contacts[i];

		Vec2* r1 = new Vec2;
    Vec2* r2 = new Vec2;
    
    r1.x = c.position.x - this.body1.position_x;
    r1.y = c.position.y - this.body1.position_y;
		r2.x = c.position.x - this.body2.position_x;
    r2.y = c.position.y - this.body2.position_y;

		// Precompute normal mass, tangent mass, and bias.
		float rn1 = r1.Dot(c.normal);
		float rn2 = r2.Dot(c.normal);
		float kNormal = this.body1.invMass + this.body2.invMass;
		kNormal += this.body1.invI * (r1.Dot(r1) - rn1 * rn1) + this.body2.invI * (r2.Dot(r2) - rn2 * rn2);
		c.massNormal = 1.0 / kNormal;

		Vec2* tangent = CrossV2S(c.normal, 1.0);
		float rt1 = r1.Dot(tangent);
		float rt2 = r2.Dot(tangent);
		float kTangent = this.body1.invMass + this.body2.invMass;
		kTangent += this.body1.invI * (r1.Dot(r1) - rt1 * rt1) + this.body2.invI * (r2.Dot(r2) - rt2 * rt2);
		c.massTangent = 1.0 /  kTangent;

		c.bias = -k_biasFactor * inv_dt * _min(0.0, c.separation + k_allowedPenetration);

		if (_accumulateImpulses)
		{
			// Apply normal + friction impulse
      Vec2* ppp = tangent.Scale(c.Pt);
			Vec2* pp = c.normal.Scale(c.Pn);
      Vec2* P = pp.Plus(ppp);
      pp = null; ppp = null;

			this.body1.velocity_x -= this.body1.invMass * P.x;
      this.body1.velocity_y -= this.body1.invMass * P.y;
      
      this.body1.angularVelocity -= this.body1.invI * r1.Cross(P);

			this.body2.velocity_x -= this.body2.invMass * P.x;
      this.body2.velocity_y -= this.body2.invMass * P.y;

      this.body2.angularVelocity -= this.body2.invI * r2.Cross(P);
		}
	}
}

void World::BroadPhase()
{
	// O(n^2) broad-phase
	for (int i = 0; i < this.body_count; i++)
	{
		Body* bi = this.bodies[i];

		for (int j = i + 1; j < this.body_count; j++)
		{
			Body* bj = this.bodies[j];

			if (bi.invMass == 0.0 && bj.invMass == 0.0)
				continue;

			Arbiter* newArb =  Arbiter.Create(bi, bj);

			if (newArb.numContacts > 0)
			{
				Arbiter* arb = this.arbiters.Get(bi, bj);
				if (arb == null)
				{
          this.arbiters.Add(arb);
				}
				else
				{
          arb.Update(newArb.contacts, newArb.numContacts);
				}
			}
			else
			{
        this.arbiters.Remove(bi, bj);
			}
		}
	}
}

void World::Step(float dt)
{
	float inv_dt = 0.0;
  if(dt > 0.0) {
    inv_dt = 1.0 / dt;
  }

	// Determine overlapping bodies and update contact points.
	this.BroadPhase();

	// Integrate forces.
	for (int i = 0; i < this.body_count; i++)
	{
		Body* b = this.bodies[i];

		if (b.invMass == 0.0)
			continue;

		b.velocity_x += dt * (this.gravity.x + b.invMass * b.force_x);
    b.velocity_y += dt * (this.gravity.y + b.invMass * b.force_y);
		b.angularVelocity += dt * b.invI * b.torque;
	}

	// Perform pre-steps.
	
  
  for (int i=0; i< this.arbiters.a_count; i++)
	{
    Arbiter* arb = this.arbiters.a[i];
    arb.PreStep(inv_dt);
	}

	for (int i = 0; i < this.joint_count; i++)
	{
    this.joints[i].PreStep(inv_dt);
	}

	// Perform iterations
	for (int i=0; i < this.iterations; i++)
	{
    for (int j=0; j< this.arbiters.a_count; j++)
    {
      Arbiter* arb = this.arbiters.a[j];
			arb.ApplyImpulse();
		}

		for (int j=0; j < this.joint_count; j++)
		{
			this.joints[j].ApplyImpulse();
		}
	}

	// Integrate Velocities
	for (int i = 0; i < this.body_count; i++)
	{
		Body* b = this.bodies[i];

		b.position_x += dt * b.velocity_x;
    b.position_y += dt * b.velocity_y;
		b.rotation += dt * b.angularVelocity;

		b.force_x = 0.0;
    b.force_y = 0.0;
		b.torque = 0.0;
	}
}
 
void game_start()
{
  _accumulateImpulses = true;
  _warmStarting = true;
  _positionCorrection = true;
}