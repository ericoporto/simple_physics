// new module script
#define FLT_MAX 340282346638528859811704183484516925440.0

// assertion check utility
void assert(bool expr)
{
  if (expr == false) AbortGame("Failed assertion!");
}

#region MATH_UTILITIES
static Vec2* Vec2::New(float x, float y) {
  Vec2* v = new Vec2;
  v.x = x;
  v.y = y;
  return v;
}
void  Vec2::Set(float x, float y) { this.x = x;  this.y = y; }
Vec2* Vec2::Negate() { return this.New(-this.x, -this.y); }
Vec2* Vec2::Minus(Vec2* v) { return this.New(this.x - v.x, this.y - v.y); }
Vec2* Vec2::Plus(Vec2* v) { return this.New(this.x + v.x, this.y + v.y); }
Vec2* Vec2::Scale(float a) { return this.New(this.x * a, this.y * a); }
float Vec2::Length(){ return Maths.Sqrt(this.x*this.x + this.y*this.y); }
float Vec2::Dot(const Vec2* b) { return this.x * b.x + this.y * b.y; }
float Vec2::Cross(const Vec2* b){	return this.x * b.y - this.y * b.x; }

static Mat22* Mat22::New(float col1_x, float col1_y, float col2_x, float col2_y)
{
  Mat22* m = new Mat22;
  m.col1_x = col1_x; m.col2_x = col2_x;
  m.col1_y = col1_y; m.col2_y = col2_y;
  return m;
}

static Mat22* Mat22::NewFromAngle(float angle)
{
  float c = Maths.Cos(angle), s = Maths.Sin(angle);
  return Mat22.New(c, s, -s, c);
}
  
static Mat22* Mat22::NewFromVec2(Vec2* col1, Vec2* col2)
{
  return Mat22.New(col1.x, col1.y, col2.x, col2.y);
}

Mat22* Mat22::Transpose() 
{
  return this.New(this.col1_x, this.col2_x, this.col1_y, this.col2_y);
}

Mat22* Mat22::Invert()
{
  float a = this.col1_x, b = this.col2_x, c = this.col1_y, d = this.col2_y;
  float det = a * d - b * c;
  assert(det != 0.0);
  det = 1.0 / det;
  return this.New(det * d, -det * c, -det * b, det * a);
}

Mat22* Mat22::Plus(const Mat22* B)
{
	return this.New(this.col1_x + B.col1_x, this.col1_y + B.col1_y, this.col2_x + B.col2_x, this.col2_y + B.col2_y);
}


Vec2* CrossV2S(const Vec2* a, float s)
{
	return Vec2.New(s * a.y, -s * a.x);
}

Vec2* CrossS2V(float s, const Vec2* a)
{
	return Vec2.New(-s * a.y, s * a.x);
}

Vec2* MultiplyVec2(const Mat22* A, const Vec2* v)
{
	return Vec2.New(A.col1_x * v.x + A.col2_x * v.y, A.col1_y * v.x + A.col2_y * v.y);
}

Mat22* Mat22::Multiply(const Mat22* matb)
{
   //A * B.col1, A * B.col2);
  float m11 = this.col1_x * matb.col1_x + this.col2_x * matb.col1_y;
  float m12 = this.col1_y * matb.col1_x + this.col2_y * matb.col1_y;
  
  float m21 = this.col1_x * matb.col2_x + this.col2_x * matb.col2_y;
  float m22 = this.col1_y * matb.col2_x + this.col2_y * matb.col2_y;
	return this.New(m11, m12, m21, m22);
}

int _maxi(int a, int b)
{
  if (a > b)
    return a;
  return b;
}

int _mini(int a, int b)
{
  if (a < b)
    return a;
  return b;
}

int _clampi(int v, int min, int max)
{
  return _mini(max, _maxi(v, min));
}

float _max(float a, float b)
{
  if (a > b)
    return a;
  return b;
}

float _min(float a, float b)
{
  if (a < b)
    return a;
  return b;
}

float _clamp(float v, float min, float max)
{
  return _min(max, _max(v, min));
}

// Random number in range [-1,1]
float _Random()
{
  float r = IntToFloat(Random(100000));
  r /= 100000.0;
  return 2.0 * r - 1.0;
}

float _RandomRange(float lo, float hi)
{
	float r = IntToFloat(Random(100000));
	r /= 100000.0;
	return (hi - lo) * r + lo;
}
#endregion //MATH_UTILITIES

bool _accumulateImpulses;
bool _warmStarting;
bool _positionCorrection;

static bool World::get_accumulateImpulses()
{
  return _accumulateImpulses;
}

static void World::set_accumulateImpulses(bool value)
{
  _accumulateImpulses = value;
}

static bool World::get_warmStarting()
{
  return _warmStarting;
}

static void World::set_warmStarting(bool value)
{
  _warmStarting = value;
}

static bool World::get_positionCorrection()
{
  return _positionCorrection;
}

static void World::set_positionCorrection(bool value)
{
  _positionCorrection = value;
}

void FeaturePair::set_value(int v)
{
  this.inEdge1 = (v >> 24) & 0xff;
  this.inEdge2 = (v >> 16) & 0xff;
  this.outEdge1 = (v >> 8) & 0xff;
  this.outEdge2 = v & 0xff;
}

int FeaturePair::get_value()
{
  return this.inEdge1 << 24 + this.inEdge2 << 16 + this.outEdge1 << 8 + this.outEdge2;
}

void Body::Set(Vec2* w, float m)
{
  this.position_x = 0.0;
  this.position_y = 0.0;
  this.rotation = 0.0;
  this.velocity_x = 0.0;
  this.velocity_y = 0.0;
  this.angularVelocity = 0.0;
  this.force_x = 0.0;
  this.force_y = 0.0;
  this.torque = 0.0;
  this.friction = 0.2;
  
  this.width_x = w.x;
  this.width_y = w.y;
  this.mass = m;

	if (this.mass < FLT_MAX)
	{
		this.invMass = 1.0 / this.mass;
		this.I = this.mass * (this.width_x * this.width_x + this.width_y * this.width_y) / 12.0;
		this.invI = 1.0 / this.I;
	}
	else
	{
		this.invMass = 0.0;
		this.I = FLT_MAX;
		this.invI = 0.0;
	}
}

enum Axis
{
	FACE_A_X,
	FACE_A_Y,
	FACE_B_X,
	FACE_B_Y
};

enum EdgeNumbers
{
	NO_EDGE = 0,
	EDGE1,
	EDGE2,
	EDGE3,
	EDGE4
};

void Flip(FeaturePair* fp)
{
	char tmp = fp.inEdge1;
  fp.inEdge1 = fp.inEdge2;
  fp.inEdge2 = tmp;
  
	tmp = fp.outEdge1; 
  fp.outEdge1 = fp.outEdge2;
  fp.outEdge2 = tmp;
}

static Arbiter* Arbiter::Create(Body* b1, Body* b2)
{
  Arbiter* a = new Arbiter;
  a.body1 = b1;
	a.body2 = b2;

	a.numContacts = Collide(a.contacts, a.body1, a.body2);

	a.friction = Maths.Sqrt(a.body1.friction * a.body2.friction);
  return a;
}

void Arbiter::Update(Contact* newContacts, int numNewContacts)
{
	Contact* mergedContacts[2];

	for (int i = 0; i < numNewContacts; ++i)
	{
		Contact* cNew = newContacts[i];
		int k = -1;
		for (int j = 0; j < numContacts; ++j)
		{
			Contact* cOld = this.contacts[j];
			if (cNew.feature.value == cOld.feature.value)
			{
				k = j;
				break;
			}
		}

		if (k > -1)
		{
			Contact* c = mergedContacts[i];
			Contact* cOld = contacts[k];
			*c = *cNew;
			if (World.warmStarting)
			{
				c->Pn = cOld->Pn;
				c->Pt = cOld->Pt;
				c->Pnb = cOld->Pnb;
			}
			else
			{
				c->Pn = 0.0f;
				c->Pt = 0.0f;
				c->Pnb = 0.0f;
			}
		}
		else
		{
			mergedContacts[i] = newContacts[i];
		}
	}

	for (int i = 0; i < numNewContacts; ++i)
		contacts[i] = mergedContacts[i];

	numContacts = numNewContacts;
} 
 