// new module script
#define MAX_JOINTS 256
#define MAX_ARBITERS 256
#define MAX_ARBITERKEYS 256
#define MAX_CONTACTS 256

// assertion check utility
void assert(bool expr)
{
  if (expr == false) AbortGame("Failed assertion!");
}

#region MATH_UTILITIES
static Vec2* Vec2::New(float x, float y) {
  Vec2* v = new Vec2;
  v.x = x;
  v.y = y;
  return v;
}
void  Vec2::Set(float x, float y) { this.x = x;  this.y = y; }
Vec2* Vec2::Negate() { return this.New(-this.x, -this.y); }
Vec2* Vec2::Minus(Vec2* v) { return this.New(this.x - v.x, this.y - v.y); }
Vec2* Vec2::Plus(Vec2* v) { return this.New(this.x + v.x, this.y + v.y); }
Vec2* Vec2::Scale(float a) { return this.New(this.x * a, this.y * a); }
float Vec2::Length(){ return Maths.Sqrt(this.x*this.x + this.y*this.y); }
float Vec2::Dot(const Vec2* b) { return this.x * b.x + this.y * b.y; }
float Vec2::Cross(const Vec2* b){	return this.x * b.y - this.y * b.x; }

static Mat22* Mat22::New(float col1_x, float col1_y, float col2_x, float col2_y)
{
  Mat22* m = new Mat22;
  m.col1_x = col1_x; m.col2_x = col2_x;
  m.col1_y = col1_y; m.col2_y = col2_y;
  return m;
}

static Mat22* Mat22::NewFromAngle(float angle)
{
  float c = Maths.Cos(angle), s = Maths.Sin(angle);
  return Mat22.New(c, s, -s, c);
}
  
static Mat22* Mat22::NewFromVec2(Vec2* col1, Vec2* col2)
{
  return Mat22.New(col1.x, col1.y, col2.x, col2.y);
}

Mat22* Mat22::Transpose() 
{
  return this.New(this.col1_x, this.col2_x, this.col1_y, this.col2_y);
}

Mat22* Mat22::Invert()
{
  float a = this.col1_x, b = this.col2_x, c = this.col1_y, d = this.col2_y;
  float det = a * d - b * c;
  assert(det != 0.0);
  det = 1.0 / det;
  return this.New(det * d, -det * c, -det * b, det * a);
}

Mat22* Mat22::Plus(const Mat22* B)
{
	return this.New(this.col1_x + B.col1_x, this.col1_y + B.col1_y, this.col2_x + B.col2_x, this.col2_y + B.col2_y);
}


Vec2* CrossV2S(const Vec2* a, float s)
{
	return Vec2.New(s * a.y, -s * a.x);
}

Vec2* CrossS2V(float s, const Vec2* a)
{
	return Vec2.New(-s * a.y, s * a.x);
}

Vec2* MultiplyVec2(const Mat22* A, const Vec2* v)
{
	return Vec2.New(A.col1_x * v.x + A.col2_x * v.y, A.col1_y * v.x + A.col2_y * v.y);
}

Mat22* Mat22::Multiply(const Mat22* matb)
{
   //A * B.col1, A * B.col2);
  float m11 = this.col1_x * matb.col1_x + this.col2_x * matb.col1_y;
  float m12 = this.col1_y * matb.col1_x + this.col2_y * matb.col1_y;
  
  float m21 = this.col1_x * matb.col2_x + this.col2_x * matb.col2_y;
  float m22 = this.col1_y * matb.col2_x + this.col2_y * matb.col2_y;
	return this.New(m11, m12, m21, m22);
}

int _maxi(int a, int b)
{
  if (a > b)
    return a;
  return b;
}

int _mini(int a, int b)
{
  if (a < b)
    return a;
  return b;
}

int _clampi(int v, int min, int max)
{
  return _mini(max, _maxi(v, min));
}

float _max(float a, float b)
{
  if (a > b)
    return a;
  return b;
}

float _min(float a, float b)
{
  if (a < b)
    return a;
  return b;
}

float _clamp(float v, float min, float max)
{
  return _min(max, _max(v, min));
}

// Random number in range [-1,1]
float _Random()
{
  float r = IntToFloat(Random(100000));
  r /= 100000.0;
  return 2.0 * r - 1.0;
}

float _RandomRange(float lo, float hi)
{
	float r = IntToFloat(Random(100000));
	r /= 100000.0;
	return (hi - lo) * r + lo;
}
#endregion //MATH_UTILITIES

#region OBJ_POOL

struct SpObjectPool {
    /// Adds a range of IDs into the list. You can keep adding more later and all the previous
    /// ones will be kept unless you call RemoveObjects or RemoveAll.
    import void AddObjects(int from, int to);
    /// Removes a range of IDs from the list.
    import void RemoveObjects(int from, int to);
    /// Removes all IDs.
    import void RemoveAll();

    /// Gives next free ID and marks it as "used". Returns -1 if no more free IDs are available.
    import int  Acquire();
    /// Marks given ID as "free".
    import void Release(int id);
    /// Marks all the known IDs as "free".
    import void ReleaseAll();
    
    /// Gets number of acquired ("used") IDs
    import int  GetAcquiredNum();
    /// Gets number of available free IDs
    import int  GetFreeNum();
    /// Gets total number of registered IDs
    import int  GetTotalNum();

    protected int _capacity;
    protected int _numUsed;
    protected bool _usingObj[];
    protected bool _isFree[];
    protected int _freeObj[];
    protected int _numFreeObj;
};

import int[] Array_ExpandIf(int arr[], int valid_count, int need_capacity, int elem_sz = 1);

int[] Array_ExpandIf(int arr[], int valid_count, int need_capacity, int elem_sz)
{
    if (valid_count >= need_capacity) { return arr; }
    int want_space = need_capacity * elem_sz;
    int new_arr[] = new int[want_space];
    int took_space = valid_count * elem_sz;
    for (int i = 0; i < took_space; i++) {
        new_arr[i] = arr[i];
    }
    return new_arr;
}
void SpObjectPool::AddObjects(int from, int to) {
    if (this._capacity <= to) {
        int new_capacity = to + 1;
        this._usingObj = Array_ExpandIf(this._usingObj, this._capacity, new_capacity);
        this._isFree = Array_ExpandIf(this._isFree, this._capacity, new_capacity);
        this._freeObj = Array_ExpandIf(this._freeObj, this._capacity, new_capacity);
        for (int i = this._capacity; i <= from; i++) {
            this._usingObj[i] = false;
            this._isFree[i] = false;
        }
        this._capacity = new_capacity;
    }
    for (int i = from; i <= to; i++) {
        if (!this._usingObj[i]) {
            this._freeObj[this._numFreeObj] = i;
            this._numFreeObj++;
            this._usingObj[i] = true;
            this._isFree[i] = true;
            this._numUsed++;
        }
    }
}
void SpObjectPool::RemoveObjects(int from, int to) {
    for (int i = from; i <= to; i++) {
        if (this._usingObj[i]) {
            for (int j = 0; j < this._numFreeObj; j++) {
                if (this._freeObj[j] == i) {
                    for (; j < this._numFreeObj - 1; j++) {
                        this._freeObj[j] = this._freeObj[j + 1];
                    }
                    this._numFreeObj--;
                }
            }
            this._isFree[i] = false;
            this._usingObj[i] = false;
            this._numUsed--;
        }
    }
}
void SpObjectPool::RemoveAll() {
    this._numFreeObj = 0;
    for (int i = 0; i < this._capacity; i++) {
        this._usingObj[i] = false;
        this._isFree[i] = false;
    }
    this._usingObj = null;
    this._isFree = null;
    this._freeObj = null;
    this._capacity = 0;
    this._numUsed = 0;
}
int SpObjectPool::Acquire() {
    if (this._numFreeObj == 0) { return -1; }
    this._numFreeObj--;
    int id = this._freeObj[this._numFreeObj];
    this._isFree[id] = false;
    return id;
}
void SpObjectPool::Release(int id) {
    if (!this._usingObj[id] || this._isFree[id]) { return; }
    this._freeObj[this._numFreeObj] = id;
    this._numFreeObj++;
    this._isFree[id] = true;
}
void SpObjectPool::ReleaseAll() {
    this._numFreeObj = 0;
    for (int i = 0; i < this._capacity; i++) {
        if (this._usingObj[i]) {
            this._freeObj[this._numFreeObj] = i;
            this._numFreeObj++;
            this._isFree[i] = true;
        }
    }
}
int SpObjectPool::GetAcquiredNum() {  return this._numUsed - this._numFreeObj; }
int SpObjectPool::GetFreeNum() { return this._numFreeObj; }
int SpObjectPool::GetTotalNum() { return this._numUsed; }

#endregion //OBJ_POOL

SpObjectPool _JointsPool;
SpObjectPool _ArbitersPool;
SpObjectPool _ArbiterKeysPool;
SpObjectPool _ContactsPool;

Joint _Joints[MAX_JOINTS];
Arbiter _Arbiters[MAX_ARBITERS];
ArbiterKey _ArbiterKeys[MAX_ARBITERKEYS];
Contact _Contacts[MAX_CONTACTS];

  
 
 
 